%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 01
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Why CI/CD Is Not Optional for AI/ML}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.52\textwidth}
\footnotesize

\textbf{What continuously changes in AI/ML}

\begin{itemize}
  \item Model parameters through retraining
  \item Training and validation data
  \item Feature engineering and preprocessing
  \item Hyperparameters and runtime configuration
\end{itemize}

\vspace{2mm}
As a consequence:
\begin{itemize}
  \item System behavior is \rtext{not fixed}
  \item Outputs depend on \y{code, data, and environment}
  \item Small changes can have \rtext{large effects}
\end{itemize}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.44\textwidth}
\footnotesize

\textbf{Why manual workflows break down}

\begin{itemize}
  \item Experiments cannot be reproduced reliably
  \item Results depend on undocumented environments or training data
  \item Errors surface \rtext{late or not at all}
  \item Deployment decisions become guesswork
\end{itemize}

\vspace{2mm}
Without automation:
\begin{itemize}
  \item Models cannot be trusted operationally
  \item Debugging becomes \rtext{forensic work}
\end{itemize}

\end{column}

\end{columns}

\vspace{2mm}
\footnotesize
\rtext{\bf CI/CD is the mechanism that makes AI/ML systems controllable and trustworthy.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 02
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{AI/ML Is Not Special — But Updating Becomes Complex}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.52\textwidth}
\footnotesize

\textbf{From a software engineering perspective}

\begin{itemize}
  \item AI/ML systems are still \y{software systems}
  \item They use standard languages, libraries and toolchains
  \item The same DevOps principles apply
\end{itemize}

\vspace{2mm}
There is \rtext{no special engineering magic} in AI/ML:
\begin{itemize}
  \item version control
  \item testing
  \item packaging
  \item deployment
\end{itemize}

\vspace{2mm}
\footnotesize
\rtext{\bf CI/CD is needed to manage updates, not to handle “AI magic”.}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.44\textwidth}
\footnotesize

\color{darkgreen}
\textbf{Where the real complexity comes from}

\begin{itemize}
  \item \color{darkgreen}
	Frequent retraining with \y{new data}
  \item Multiple preprocessing and feature pipelines
  \item Changing \y{model architectures}
  \item Different \y{loss functions} and objectives
  \item Many runtime and training configurations
\end{itemize}

\vspace{2mm}
As a result:
\begin{itemize}
  \item Updates are \rtext{continuous}
  \item Reproducibility becomes \rtext{non-trivial}
  \item Manual tracking no longer works
\end{itemize}

\end{column}

\end{columns}


\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 03
% ================================================================================
\begin{frame}[t]

\vspace{-2mm}
\begin{center}
  \includegraphics[width=0.95\textwidth]{../../images/img14/full_story_data_to_deployment.png}
\end{center}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 04
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Starting Locally: A Concrete Git Hook Example}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.52\textwidth}
\footnotesize

{\bf Black} is an \y{automatic code formatter} for Python.

{\sl 
It rewrites Python source code into a single, consistent style, without asking questions.
}

\vspace{2mm}
\textbf{Minimal pre-commit hook}

\begin{codeonly}{.git/hooks/pre-commit}
#!/bin/sh
pytest || exit 1
black .
\end{codeonly}

\vspace{1mm}
This hook is executed automatically when running:
\begin{itemize}
  \item \texttt{git commit}
\end{itemize}

If tests fail, the commit is \rtext{blocked}.

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.44\textwidth}
\footnotesize

\textbf{What this enforces locally}

\begin{itemize}
  \item Code must be \y{syntactically correct}
  \item Tests must \y{pass}
  \item Code formatting is \y{consistent}
\end{itemize}

\vspace{2mm}
Key properties:
\begin{itemize}
  \item Runs \rtext{before} code leaves the laptop
  \item No CI server involved
  \item Immediate feedback to the developer
\end{itemize}

\end{column}

\end{columns}

\vspace{2mm}
\footnotesize
\rtext{\bf Git hooks enforce local discipline — not global policy.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 05
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{When Are Git Hooks Executed?}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.52\textwidth}
\footnotesize

\textbf{Git commands trigger hooks}

Git automatically executes hooks at
\y{well-defined points} in its workflow.

\vspace{2mm}
Common examples:
\begin{itemize}
  \item \texttt{pre-commit} — before a commit is created
  \item \texttt{commit-msg} — to validate commit messages
  \item \texttt{pre-push} — before pushing to a remote
\end{itemize}

\vspace{2mm}
Hooks run \rtext{before} Git completes the command.

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.44\textwidth}
\footnotesize

\textbf{Effect on the workflow}

\begin{itemize}
  \item Hook succeeds $\rightarrow$ Git continues
  \item Hook fails $\rightarrow$ Git aborts the command
\end{itemize}

\vspace{2mm}
This means:
\begin{itemize}
  \item Invalid code never enters the repository
  \item Errors are caught \y{immediately}
  \item No manual checks are required
\end{itemize}

\vspace{2mm}
Hooks are \rtext{deterministic}:
same input $\rightarrow$ same outcome.

\end{column}

\end{columns}

\vspace{2mm}
\footnotesize
\rtext{\bf Hooks turn Git commands into enforced quality gates.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 06
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{A Git Hook in Action: What Actually Happens}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.48\textwidth}
\footnotesize

\vspace{-2mm}
\textbf{Before committing}

\begin{itemize}
  \item Python test file is \rtext{poorly formatted}
  \item Code is syntactically valid
  \item Tests pass when run manually
\end{itemize}

\vspace{0mm}
After running \texttt{black}:
\begin{itemize}
  \item Formatting is rewritten automatically
  \item No code logic is changed
\end{itemize}

\textbf{During \texttt{git commit}}

\begin{itemize}
  \item \texttt{pytest} is executed automatically
  \item \texttt{black} is executed automatically
  \item Both run via the \y{pre-commit hook}
\end{itemize}

\vspace{0mm}
\footnotesize
\rtext{\bf The hook turns a manual checklist into an automatic guarantee.}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.42\textwidth}
\footnotesize


\vspace{-3mm}
{\bf Outcome:}
\begin{itemize}
  \item Tests pass
  \item Formatting is consistent
  \item Commit is \y{accepted}
\end{itemize}

\hspace{-3mm}\color{black}\rule{0.5pt}{4cm}

\vspace{-4.3cm}
\begin{minipage}{7cm}
\tiny\color{red}
\begin{lstlisting}
def add( a ,b ):
  return a+b
def test_answer( ):
  print("Testing add(1, 3) == 4")
  assert add(1,3)==4
\end{lstlisting}

\vspace{-2mm}
\color{darkgreen}
\begin{lstlisting}
def add(a, b):
    return a + b
def test_answer():
    print("Testing add(1, 3) == 4")
    assert add(1, 3) == 4
\end{lstlisting}
\end{minipage}

\end{column}

\end{columns}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 07
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Strengths and Limits of Git Hooks}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.50\textwidth}
\footnotesize

\textbf{Strengths}

\begin{itemize}
  \item \y{Extremely fast feedback}. Helps you!!
  \item No external infrastructure required
  \item Works offline
  \item Integrated directly into Git commands
\end{itemize}

\vspace{2mm}
Git hooks are ideal for:
\begin{itemize}
  \item formatting checks
  \item unit tests
  \item catching trivial mistakes early
\end{itemize}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.46\textwidth}
\footnotesize

\textbf{Limitations}

\begin{itemize}
  \item Run only on the developer machine
  \item Not enforced across a team
  \item Can be bypassed or disabled
  \item No neutral execution environment
\end{itemize}

\vspace{2mm}
As a consequence:
\begin{itemize}
  \item Hooks improve discipline
  \item But they do \rtext{not guarantee quality}
\end{itemize}

\end{column}

\end{columns}

\vspace{4mm}
\footnotesize
\rtext{\bf Git hooks accelerate development — CI platforms enforce standards.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 08
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Formatting vs Behavior: Two Different Checks}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.50\textwidth}
\footnotesize

\vspace{-2mm}
\textbf{Code formatting (Black)}

\begin{itemize}
  \item Enforces a consistent style
  \item Removes whitespace and layout differences
  \item Does \rtext{not} change program logic
\end{itemize}

\vspace{2mm}
Example:
\begin{codeonly}{black reformats code}
def add( a ,b ):
  return a+b
\end{codeonly}

becomes:
\begin{codeonly}{}
def add(a, b):
    return a + b
\end{codeonly}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.46\textwidth}
\footnotesize

\textbf{Behavior testing (pytest)}

\begin{itemize}
  \item Checks whether code does the \y{right thing}
  \item Executes functions and validates results
  \item Fails if behavior changes unexpectedly
\end{itemize}

\vspace{2mm}
Formatting makes code readable.  
Testing makes code \rtext{\bf correct}.

\end{column}

\end{columns}

\vspace{2mm}
\footnotesize
\rtext{\bf Style and correctness are independent concerns.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 09
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Code and Test: Defining and Enforcing Behavior}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.48\textwidth}
\footnotesize

\textbf{Formatted Code}

\begin{codeonly}{test\_example.py}
def add(a, b):
    return a + b
\end{codeonly}

\vspace{2mm}
This code:
\begin{itemize}
  \item is syntactically correct
  \item is well formatted
  \item may still be \rtext{logically wrong}
\end{itemize}

\vspace{2mm}
Formatting alone cannot guarantee correctness.

\vspace{2mm}
\footnotesize
\y{\rtext{\bf Correct behavior is defined by function tests,}}
\y{\rtext{\bf not by appearance.}}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.48\textwidth}
\footnotesize

\textbf{Test that enforces behavior}

\begin{codeonly}{test\_example.py}
def test_add():
    assert add(2, 3) == 5
\end{codeonly}

\vspace{0mm}
This test:
\begin{itemize}
  \item executes the function
  \item checks the expected result
  \item fails automatically if behavior changes
\end{itemize}

\vspace{0mm}
The test can run:
\begin{itemize}
  \item locally
  \item in Git hooks
  \item in CI pipelines
\end{itemize}

\end{column}

\end{columns}


\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 10
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{CI/CD Tools: \y{Local Discipline and Correctness}}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.48\textwidth}
\footnotesize

\vspace{-2mm}
\textbf{Version control}

\begin{itemize}
  \item \textbf{Git} \\
  {\tiny Tracks changes to source code and configuration files, enabling
  branching, merging, and full reconstruction of development history.}
  
  \item \textbf{GitHub / GitLab} \\
  {\tiny Hosting platforms for Git repositories, providing collaboration,
  access control, and CI integration.}
\end{itemize}

\vspace{0mm}
\textbf{Local enforcement}

\begin{itemize}
  \item \textbf{Git hooks} \\
  {\tiny Local scripts executed automatically on Git events
  (e.g.\ \texttt{pre-commit}) to enforce rules before code is committed.}

  \item \textbf{pre-commit framework} \\
  {\tiny Version-controlled hook manager that ensures identical checks across
  developers and CI environments.}
\end{itemize}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.48\textwidth}
\footnotesize

\textbf{Code quality and correctness}

\begin{itemize}
  \item \textbf{Black} \\
  {\tiny Automatic Python formatter that enforces a single,
  deterministic code style without configuration decisions.}

  \item \textbf{pytest} \\
  {\tiny Python testing framework that executes test functions and
  fails automatically when expected behavior is violated.}
\end{itemize}

\vspace{0mm}
These tools:
\begin{itemize}
  \item run fast
  \item provide immediate feedback
  \item prevent trivial errors from propagating
\end{itemize}

\vspace{2mm}
\footnotesize
\rtext{\bf Local discipline reduces error rates before CI even starts.}

\end{column}

\end{columns}



\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 11
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{CI/CD Tools: Automation and Execution}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.48\textwidth}
\footnotesize

\y{\textbf{CI orchestration}}

\begin{itemize}
  \item \textbf{GitHub Actions} \\
  {\tiny Event-driven CI system integrated into GitHub, executing workflows
  defined in YAML on managed runners.}

  \item \textbf{GitLab CI} \\
  {\tiny Pipeline-based CI system configured via \texttt{.gitlab-ci.yml},
  supporting self-hosted and specialized runners (e.g.\ HPC, GPU).}

  \item \textbf{Jenkins} \\
  {\tiny Standalone automation server using scripted pipelines,
  common in legacy and enterprise environments.}
\end{itemize}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.48\textwidth}
\footnotesize

\y{\textbf{Execution environments}}

\begin{itemize}
  \item \textbf{Python virtual environments} \\
  {\tiny Isolate Python dependencies to ensure reproducible runtime behavior.}

  \item \textbf{Containers (Docker, Apptainer)} \\
  {\tiny Package applications and dependencies into portable,
  reproducible execution units across systems.}
\end{itemize}

\vspace{2mm}
\y{\textbf{Artifacts}}

\begin{itemize}
  \item \textbf{CI artifacts and registries} \\
  {\tiny Store outputs such as logs, test reports, trained models,
  and container images produced during pipelines.}
\end{itemize}

\end{column}

\end{columns}

\vspace{4mm}
\centering
\footnotesize
\rtext{\bf CI platforms enforce rules; environments make them reproducible.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 12
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Why Data Formats Matter in AI/ML}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.50\textwidth}
\footnotesize

\textbf{Characteristics of training data}

\begin{itemize}
  \item Very large (GB–TB scale)
  \item Multi-dimensional (time, space, channels)
  \item Often produced continuously
\end{itemize}

\vspace{2mm}
In contrast to classical workflows:
\begin{itemize}
  \item Data rarely fits into memory
  \item Full sequential reads are uncommon
\end{itemize}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.46\textwidth}
\footnotesize

\textbf{Typical ML access patterns}

\begin{itemize}
  \item Repeated sampling of small subsets
  \item Random or structured access
  \item Parallel reading by many workers
\end{itemize}

\vspace{2mm}
As a result, the \y{data format} directly affects:
\begin{itemize}
  \item I/O performance
  \item Scalability of training
  \item Feasibility of distributed ML
\end{itemize}

\end{column}

\end{columns}

\vspace{2mm}
\footnotesize
\rtext{\bf Data formats are part of the ML infrastructure, not just storage.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 13
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Zarr: Why It Is Attractive for AI/ML}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.50\textwidth}
\footnotesize

\textbf{Design principles}

\begin{itemize}
  \item Chunked, array-based storage
  \item Designed for cloud and HPC
  \item Partial reads without full downloads
\end{itemize}

\vspace{2mm}
\textbf{Performance features}

\begin{itemize}
  \item Parallel reads of independent chunks
  \item Flexible chunk layout
  \item Compression per chunk
\end{itemize}

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.46\textwidth}
\footnotesize

\textbf{Why this helps ML training}

\begin{itemize}
  \item Efficient random sampling
  \item Scales to distributed workers
  \item Reduces I/O bottlenecks
\end{itemize}

\vspace{2mm}
\textbf{Typical use cases}

\begin{itemize}
  \item Images and video
  \item Satellite and geospatial data
  \item Scientific simulation output
\end{itemize}

\end{column}

\end{columns}

\vspace{2mm}
\footnotesize
\rtext{\bf Zarr optimizes data access patterns — not the ML logic itself.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14 — Slide 14
% ================================================================================
\begin{frame}[t,fragile]

\mytitle{Zarr: Limitations and When to Use Alternatives}

\begin{columns}[T,totalwidth=\textwidth]

% ------------------------------------------------------------
\begin{column}[T]{0.50\textwidth}
\footnotesize

\textbf{Limitations}

\begin{itemize}
  \item Limited native integration with ML frameworks
  \item Metadata overhead for many small arrays
  \item Not well suited for tabular data
  \item Care needed for concurrent writes
\end{itemize}

\vspace{2mm}
Zarr adds complexity that is not always justified.

\end{column}

% ------------------------------------------------------------
\begin{column}[T]{0.46\textwidth}
\footnotesize

\textbf{When to choose alternatives}

\begin{itemize}
  \item Tabular ML data: \y{Parquet}, Arrow
  \item TensorFlow pipelines: \y{TFRecord}
  \item PyTorch streaming: \y{WebDataset}
  \item Small datasets: NetCDF, HDF5, NPY
\end{itemize}

\vspace{2mm}
\textbf{Guiding principle}

\begin{itemize}
  \item Choose formats based on data structure
  \item Optimize for access pattern, not fashion
\end{itemize}

\end{column}

\end{columns}

\vspace{2mm}
\footnotesize
\rtext{\bf Zarr is powerful when the problem matches the format.}

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 15
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 15}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 16
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 16}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 17
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 17}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 18
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 18}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 19
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 19}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 20
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 20}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 21
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 21}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 22
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 22}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 23
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 23}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 24
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 24}

  % Content goes here

\end{frame}
%!TEX root = lec14.tex
% ================================================================================
% Lecture 14, Slide 25
% ================================================================================
\begin{frame}[t,fragile]
  \mytitle{Lecture 14 — Slide 25}

  % Content goes here

\end{frame}
